import{_ as s,c as i,o as a,a2 as e}from"./chunks/framework.BV61Qrc0.js";const E=JSON.parse('{"title":"字符串","description":"","frontmatter":{},"headers":[],"relativePath":"solidity/string.md","filePath":"solidity/string.md"}'),n={name:"solidity/string.md"},l=e(`<h1 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-label="Permalink to &quot;字符串&quot;">​</a></h1><p><code>Solidity</code> 是一种面向智能合约的编程语言，支持字符串类型。字符串是以双引号或单引号引起来的文本。</p><p>在 <code>Solidity</code> 中，字符串类型有两种：</p><ul><li><p><code>bytes</code>: 用于表示二进制数据的字符串, 如：<code>0x01ffab</code>。</p></li><li><p><code>string</code>: 用于表示普通文本数据的字符串，如 <code>Hello, World!</code>。</p></li></ul><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><p>下面是一个简单的 <code>Solidity</code> 程序示例，演示了如何定义和使用字符串类型：</p><div class="language-solidity vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pragma</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;"> solidity</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ^0.8.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">contract</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StringExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> memory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _newMessage) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _newMessage;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> view</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> returns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> memory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> message;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个程序中，<code>string message</code> 定义了一个字符串类型变量 <code>message</code>。<code>setMessage()</code> 函数用于设置一个新的字符串信息，<code>getMessage()</code> 函数用于返回保存的字符串信息。</p><p>可以用 <code>Remix</code> 编译器来测试该 <code>Solidity</code> 程序：</p><ul><li><p>在 <code>Remix</code> 编译器中，切换到 <code>Solidity compiler</code> 选项卡。</p></li><li><p>复制并粘贴上面的 <code>Solidity</code> 程序到 <code>Remix</code> 编译器中。</p></li><li><p>编译 <code>Solidity</code> 程序并确保没有任何错误。</p></li><li><p>切换到 <code>Deploy &amp; Run Transactions</code> 选项卡。</p></li><li><p>点击 <code>Deploy Contract</code> 按钮来部署合约。</p></li><li><p>等待合约在区块链上部署完成。</p></li><li><p>在 <code>Deployed Contracts</code> 区域中，选择 <code>StringExample</code> 合约，并在 <code>setMessage</code> 函数中输入一个字符串参数。</p></li><li><p>点击 <code>Transact</code> 按钮来执行 <code>setMessage</code> 函数。</p></li><li><p>再次选择 <code>StringExample</code> 合约，并在 <code>getMessage</code> 函数中点击 <code>Call</code> 按钮来获取之前设置的字符串信息。</p></li></ul><p>输出应该是和之前设置的相同的字符串信息。这样你就可以通过 <code>Solidity</code> 程序来操作和存储字符串了。</p>`,11),t=[l];function p(d,h,o,c,k,r){return a(),i("div",null,t)}const y=s(n,[["render",p]]);export{E as __pageData,y as default};
